import sys
import re  # to replace string "Inner*" from newick tree generated by biopython, not compatible with ete3
from Bio.Phylo.TreeConstruction import (
    DistanceMatrix,
)  # to construct distance matrix from plink IBS square matrix
from Bio.Phylo.TreeConstruction import (
    DistanceTreeConstructor,
)  # to construct NJ or UPGMA tree from constructed distance matrix
from Bio import Phylo  # to export tree in newick format
import toytree  # read tree in newick format in toytree package to plot it interactively
import toyplot.html  # save interactive tree in html forat
import toyplot.svg  # save interactive tree in svg format
from ete3 import Tree  # identify population whose samples are not monophyletic
import yaml  # read configuration for interactive nj plot
from yaml.loader import SafeLoader
import argparse


def read_dist_file(dist_mat, sample_map):
    pairwise_ibs_dict = {}
    sample_list = []
    mat_lines = []
    with open(sample_map) as source:
        for line in source:
            line = line.rstrip().split()
            sample_list.append(line[1])
    with open(dist_mat) as source:
        for line in source:
            line = line.rstrip().split()
            mat_lines.append(line)
    for i, v in enumerate(sample_list):
        for j, w in enumerate(sample_list[i + 1 :]):
            pairwise_ibs_dict[v + "_" + w] = float(mat_lines[i][sample_list.index(w)])
    sample_list.sort()
    return pairwise_ibs_dict, sample_list


def make_sample_color_dict(sample_map, pop_color_file):
    sample_color_dict = {}
    pop_color_dict = {}
    with open(pop_color_file) as source:
        for line in source:
            line = line.rstrip().split()
            pop_color_dict[line[0]] = line[2]
    with open(sample_map) as source:
        for line in source:
            line = line.rstrip().split()
            sample_color_dict[line[1]] = [line[0], pop_color_dict[line[0]]]
    return sample_color_dict


def plot_interactive_tree(newickfile, sample_color_dict, plot_yml, outgroup):
    newick = ""
    color_list = []
    with open(plot_yml, "r") as p:
        params = yaml.load(p, Loader=SafeLoader)
    hgt = params["height"]
    wth = params["width"]
    layo = params["layout"]
    tla = params["tip_label_align"]
    tlf = params["tip_label_font_size"]
    ns = params["node_sizes"]
    nh = params["node_hover"]
    tas = params["toyplot-anchor-shift"]
    ew = params["edge_widths"]
    with open(newickfile) as source:
        for line in source:
            line = line.rstrip()
            newick = line
    tre1 = toytree.tree(newick, tree_format=1)
    if outgroup != "none":
        outgroup_sample_list = [
            k for k, v in sample_color_dict.items() if v[0] == outgroup
        ]
        tre1 = tre1.root(names=outgroup_sample_list)
    sample_list = tre1.get_tip_labels()
    nodeidx_sample = tre1.get_node_dict()
    sample_nodeidx = {v: k for k, v in nodeidx_sample.items()}
    pop_feature = {}
    for sample in sample_nodeidx:
        pop_feature[sample_nodeidx[sample]] = sample_color_dict[sample][0]
    tre1 = tre1.set_node_values(
        feature="pop",
        values=pop_feature,
    )
    for sample in sample_list:
        color_list.append(sample_color_dict[sample][1])
    tre1.write(newickfile + "_rooted.tree")
    canvas, axes, mark = tre1.draw(
        height=hgt,
        width=wth,
        layout=layo,
        node_hover=nh,
        node_sizes=ns,
        tip_labels_align=tla,
        edge_widths=ew,
        tip_labels_colors=color_list,
        tip_labels_style={
            "font-size": tlf,
            "-toyplot-anchor-shift": tas,
        },
    )
    toyplot.html.render(canvas, newickfile + ".html")
    toyplot.svg.render(canvas, newickfile + ".svg")


def check_monophyly(newick_f, sample_color_dict):
    sample_pop_dict = {}
    dest = open("polyphyletic_pop_list.txt", "w")
    with open(newick_f) as source:
        for line in source:
            line = line.rstrip()
    line = re.sub("(Inner[0-9]+)", "", line)
    ete3_tree = Tree(line)
    pop_sample_dict = {}
    for sample in sample_color_dict:
        pop = sample_color_dict[sample][0]
        sample_pop_dict[sample] = pop
        if pop not in pop_sample_dict:
            pop_sample_dict[pop] = []
        pop_sample_dict[pop].append(sample)
    for leaf in ete3_tree:
        leaf.add_features(sample_pop=sample_pop_dict.get(leaf.name, "none"))
    for pop in pop_sample_dict:
        if not ete3_tree.check_monophyly(values=[pop], target_attr="sample_pop")[0]:
            dest1 = open(pop + "_monophyletic_subtrees.txt", "w")
            tree_count = 0
            for node in ete3_tree.get_monophyletic(
                values=[pop], target_attr="sample_pop"
            ):
                tree_count += 1
                dest1.write("monophyletic nodes count " + str(tree_count) + "\n")
                dest1.write(
                    str(node.get_ascii(attributes=["name"], show_internal=True))
                )
                dest1.write("\n")
            dest1.close()
            dest.write(pop + "\n")
    dest.close()


def make_ibs_dist_nj_tree(
    ibs_dist, sample_map, newick, tree, outgroup, f_pop_color, plot_yml, out_prefix
):
    sample_color_dict = make_sample_color_dict(sample_map, f_pop_color)
    if newick == "none":
        pairwise_ibs_dict, sample_list = read_dist_file(ibs_dist, sample_map)
        distance_list = []
        dest = open(out_prefix + ".ibs.dist", "w")
        dest.write(" " + str(len(sample_list)) + "\n")
        for i, v in enumerate(sample_list):
            tmp_list = []
            col1 = v + " " * (10 - len(v)) if len(v) < 10 else v[:10] + " "
            dest.write(col1)
            for it, vt in enumerate(sample_list[:i]):
                fst = (
                    pairwise_ibs_dict[v + "_" + vt]
                    if v + "_" + vt in pairwise_ibs_dict
                    else pairwise_ibs_dict[vt + "_" + v]
                )
                tmp_list.append(round(fst, 4))
            tmp_list.append(0)
            tmp_list_w = ["{:.4f}".format(x) for x in tmp_list]
            dest.write(" ".join(tmp_list_w) + "\n")
            distance_list.append(tmp_list[:])
        dm = DistanceMatrix(sample_list, distance_list)
        constructor = DistanceTreeConstructor()
        if tree == "UPGMA":
            tree = constructor.upgma(dm)
        else:
            tree = constructor.nj(dm)
        Phylo.write(tree, out_prefix + ".tree", "newick")
        plot_interactive_tree(
            out_prefix + ".tree", sample_color_dict, plot_yml, outgroup
        )
        check_monophyly(out_prefix + ".tree", sample_color_dict)
        dest.close()
    else:
        plot_interactive_tree(newick, sample_color_dict, plot_yml, outgroup)
        check_monophyly(newick, sample_color_dict)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="A small python script to generate NJ-based tree based on pairwise-Fst distances generated \
    using vcftools",
        epilog="author: Maulik Upadhyay (Upadhyay.maulik@gmail.com)",
    )
    parser.add_argument(
        "-i",
        "--ibs_dist_square",
        metavar="String",
        default="none",
        help="plink1.9 generated square 1-ibs ditance matrices",
        required=False,
    )
    parser.add_argument(
        "-m",
        "--sample_map",
        metavar="String",
        help='sample map file with fist column as fam id and second column as sample id (also generated with --distance command in plink 1.9 with extension "mdist.id"',
        required=True,
    )
    parser.add_argument(
        "-n",
        "--newick",
        metavar="String",
        help="tree file in newick format",
        default="none",
        required=False,
    )
    parser.add_argument(
        "-t",
        "--tree",
        metavar="String",
        help="type of algorithms to be used in building tree: NJ or UPGMA (defualt = NJ) \
    ",
        default="NJ",
        required=False,
    )
    parser.add_argument(
        "-r",
        "--outgroup",
        metavar="String",
        help="population name to be used as outgroup",
        default="none",
        required=False,
    )
    parser.add_argument(
        "-c",
        "--pop_color",
        metavar="String",
        default="none",
        help="path to the text file containing pop id as first column and hex id of a color in the second column",
        required=False,
    )
    parser.add_argument(
        "-y",
        "--plot_nj_yml",
        metavar="String",
        help="path to the yml file containing parameters to plot interactive nj tree. Refer to ./paramteres/plot_nj_tree/ibs_nj.yml",
        required=True,
    )
    parser.add_argument(
        "-o", "--out_prefix", metavar="File", help="output prefix", required=True
    )

    args = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)
    elif args.ibs_dist_square == "none" and args.newick == "none":
        print(
            "ERROR: --ibs_dist_square, Either square 1-ibs distance matrix generated by Plink1.9, or --newick, tree in newick format is required"
        )
        sys.exit(1)
    elif args.tree not in ["NJ", "UPGMA"]:
        print("ERROR: the tree option should either be NJ or UPGMA")
        sys.exit(1)
    else:
        make_ibs_dist_nj_tree(
            args.ibs_dist_square,
            args.sample_map,
            args.newick,
            args.tree,
            args.outgroup,
            args.pop_color,
            args.plot_nj_yml,
            args.out_prefix,
        )
